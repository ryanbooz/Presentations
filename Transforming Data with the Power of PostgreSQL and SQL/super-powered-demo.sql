/*
 * Create a simple table and copy text line-by-line
 * with auto ID column
 */
--DROP TABLE IF EXISTS dec07;
--TRUNCATE dec07;
create table dec07 (
	id integer generated by default as identity,
	lines text
);

/*
 * Run in psql from directory of 'input.txt'
 * to populate the simple "staging" table
 */
--\copy dec07(lines) FROM input.txt NULL '';

/*
 * simple insert for demo
 */
INSERT INTO dec07 (lines) VALUES 
	('32T3K 765'),
	('T55J5 684'),
	('KK677 28'),
	('KTJJT 220'),
	('QQQJA 483');

SELECT * FROM dec07;

/*
 * Alternatively, for quick prototyping, copy some sample
 * data into a CTE that returns row-by-row data. For text,
 * 'string_to_table' or 'rexexp_split_to_table' are good 
 * options
 */
-- demo dollar quoting
SELECT $$32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483$$;

-- Dollar quoteing is really helpful with functions
-- like format()
SELECT format($$This is a demo for %s!!$$, 'Scale 21x');


SELECT regexp_split_to_table($$32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483$$,'\n') lines;

WITH dec07_dt AS (
	SELECT * FROM regexp_split_to_table($$32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483$$,'\n') lines
)
SELECT * FROM dec07_dt;


SELECT ROW_NUMBER() OVER() AS id, *  FROM (
	-- This is the derived table, named â€˜dec07â€™ in place
	-- of an actual table that data has been inserted into
	SELECT regexp_split_to_table($$32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483$$,'\n') lines
) dec07_dt;

-- CTE with ROW_NUMBER()
WITH dec07_dt AS (
	SELECT ROW_NUMBER() OVER() AS id, lines 
		FROM regexp_split_to_table($$32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483$$,'\n') lines
)
SELECT * FROM dec07_dt;

-- WITH ORDINALITY
WITH dec07_dt AS (
	SELECT * FROM regexp_split_to_table($$32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483$$,'\n') WITH ORDINALITY lines(lines,id)
)
SELECT id, lines FROM dec07_dt;


WITH dec07_dt AS (
	SELECT * FROM regexp_split_to_table($$32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483$$,'\n') WITH ORDINALITY lines(lines,id)
)
SELECT id AS hand,
	split_part(lines,' ',1) AS cards, 
	split_part(lines,' ',2) AS bid 
FROM dec07_dt;

/*
 * now with real data
 */
SELECT id AS hand,
	split_part(lines,' ',1) AS cards, 
	split_part(lines,' ',2) AS bid 
FROM dec07;

-- Split each hand into individual cards
-- with their position in the hand left to right
SELECT id AS hand, 
	  t.* AS card, 
      (split_part(lines,' ',2)) AS bid
FROM dec07, --> CROSS JOIN LATERAL
     string_to_table(split_part(lines,' ',1),null)
     	WITH ORDINALITY t(card,position);Â 

-- Same thing, but cleaned up with 
SELECT id AS hand, 
	t.card, 
	t.position, 
	bid 
FROM dec07, 
     string_to_table(split_part(lines,' ',1),null) 
		WITH ORDINALITY t(card,position),
     split_part(lines,' ',2) bid;


/*
 * Fun with arrays and WORDLE!
 * 
 * Same principles as above, and by using cross joins, we can
 * rerences the output of each set to do additional work on it.
 */
SELECT $$Not as easy as you think
		#Wordle 511 3/6*
		ğŸŸ¨â¬œğŸŸ¨â¬œâ¬œ
		â¬œğŸŸ¨ğŸŸ¨ğŸŸ¨ğŸŸ¨
		ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©
	$$;


select * from 
	regexp_matches($$Not as easy as you think
		#Wordle 511 3/6*
		ğŸŸ¨â¬œğŸŸ¨â¬œâ¬œ
		â¬œğŸŸ¨ğŸŸ¨ğŸŸ¨ğŸŸ¨
		ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©
	$$,'([ğŸŸ©|ğŸŸ§|ğŸŸ¨|ğŸŸ¦|â¬›|â¬œ|]{5})','g') 
		WITH ORDINALITY AS g(guess, guess_num)


-- The output of this CTE would be one row for each word guess
-- of a puzzle, three in the case of the example below.
WITH wordle_score AS (
		select * from 
		regexp_matches($$Not as easy as you think
			#Wordle 511 3/6*
			ğŸŸ¨â¬œğŸŸ¨â¬œâ¬œ
			â¬œğŸŸ¨ğŸŸ¨ğŸŸ¨ğŸŸ¨
			ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©
		$$,'([ğŸŸ©|ğŸŸ§|ğŸŸ¨|ğŸŸ¦|â¬›|â¬œ|]{5})','g') 
			WITH ORDINALITY AS g(guess, guess_num)
)					
SELECT * FROM wordle_score;


-- Break it apart even further to get each separate letter
WITH wordle_score AS (
		select * from 
		regexp_matches($$Not as easy as you think
			#Wordle 511 3/6*
			ğŸŸ¨â¬œğŸŸ¨â¬œâ¬œ
			â¬œğŸŸ¨ğŸŸ¨ğŸŸ¨ğŸŸ¨
			ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©
		$$,'([ğŸŸ©|ğŸŸ§|ğŸŸ¨|ğŸŸ¦|â¬›|â¬œ|]{5})','g') 
			WITH ORDINALITY AS g(guess, guess_num)
)					
SELECT *
FROM wordle_score ws,-- CROSS JOIN LATERAL
	regexp_matches(ws.guess[1],'([â¬›|ğŸŸ©|ğŸŸ¨|â¬œ]{1})','g') 
		WITH ORDINALITY AS r(c1, letter)

	
	
-- Now we can aggregate those individual letters
-- to see how many letters were right/wrong for each guess
WITH wordle_score AS (
	select * from 
		regexp_matches($$Not as easy as you think
			#Wordle 511 3/6*
			ğŸŸ¨â¬œğŸŸ¨â¬œâ¬œ
			â¬œğŸŸ¨ğŸŸ¨ğŸŸ¨ğŸŸ¨
			ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©
		$$,'([ğŸŸ©|ğŸŸ§|ğŸŸ¨|ğŸŸ¦|â¬›|â¬œ|]{5})','g') 
			WITH ORDINALITY AS g(guess, guess_num)
)					
SELECT 
	guess_num,
	count(*) FILTER (WHERE c1[1]='ğŸŸ©') AS c_correct,
	count(*) FILTER (WHERE c1[1]='ğŸŸ¨') AS c_partial,
	count(*) FILTER (WHERE c1[1] IN ('â¬›','â¬œ')) AS c_incorrect
FROM wordle_score ws,
	regexp_matches(ws.guess[1],'([â¬›|ğŸŸ©|ğŸŸ¨|â¬œ]{1})','g') 
		WITH ORDINALITY AS r(c1, letter)
GROUP BY 1;



/*
 * Recursive queries
 * 
 * These are two more straight forward examples of recursive queries.
 * 
 * In the Advent of Code solutions, using recursive queries was necessary
 * to handle many of the puzzles because they required referenceing previous
 * data transformations. In SQL, a recursive query is the only way to do
 * that unless you write a function or stored procedure. That would be a 
 * fine option, but my original goal was to just use SQL directly.
 * 
 * The first example uses a very simple set of data (above) to show
 * two iterations of a filesystem listing to fine parent/child relationships.
 */


-- start at 1 and count to 10
WITH RECURSIVE count_value AS (
	SELECT 1 AS value 
	UNION ALL
	SELECT value + 1 FROM count_value
	WHERE value < 10
)
SELECT * FROM count_value;



-- Another example using the Fibonacci Sequence
WITH RECURSIVE fib_seq(level,pnum,cnum) AS
(
	SELECT 1 ,0::numeric, 1::numeric 
	UNION ALL
	SELECT fib_seq.LEVEL+1, 
		   fib_seq.cnum,
		   fib_seq.pnum+fib_seq.cnum 
	   FROM fib_seq
 	-- Stop at a certain level 
 	WHERE fib_seq.level <= 50
)
SELECT * FROM fib_seq;

/*
 * Setup for initial Recursive query example
 */
CREATE TABLE IF NOT EXISTS files_on_disk (
	name TEXT,
	parent_folder TEXT,
	SIZE bigint
);

TRUNCATE files_on_disk;

INSERT INTO files_on_disk VALUES
	('Folder_A',NULL,NULL),
	('Folder_A_1','Folder_A',NULL),
	('Folder_B','Folder_A',NULL),
	('Folder_A_2','Folder_A',NULL),
	('Folder_B_1','Folder_B',NULL),
	('File_A1.txt','Folder_A',1234),
	('File_A2.txt','Folder_A',6789),
	('File_B1.txt','Folder_B',4567);


SELECT * FROM files_on_disk;

WITH recursive files AS (
	-- this is the static, non-recursive query that gets things started
	-- and fills the "working table" with the first set of data to JOIN 
	-- to in the recursive query after the UNION
	SELECT name, parent_folder, SIZE FROM files_on_disk
	WHERE parent_folder IS NULL
	UNION
	-- this is the recursive query. because it is the table on disk
	-- back to the output of the last iteration, we can iterate
	-- a set of data to find relationships and reach backward
	SELECT fid.name, fid.parent_folder AS parent_path, 
	    fid.SIZE FROM files_on_disk fid
		INNER JOIN files f ON fid.parent_folder = f.name
)
SELECT * FROM files;

/*
 * Break it down a bit...
 */
-- Results of first join
SELECT fid.name, fid.parent_folder AS parent_path, 
	    fid.SIZE FROM files_on_disk fid
	   WHERE parent_folder = 'Folder_A';

-- Results of second join
SELECT fid.name, fid.parent_folder AS parent_path, 
	    fid.SIZE FROM files_on_disk fid
	   WHERE parent_folder = 
	  		ANY('{Folder_A_1,Folder_B,Folder_A_2,File_A1.txt,File_A2.txt}');

/*
 * The same example as above, but now we're actually using data from the
 * previous iteration to build a "file path".
 */
WITH recursive files AS (
	SELECT name, COALESCE(parent_folder,'') parent_path, SIZE FROM files_on_disk
	WHERE parent_folder IS NULL
	UNION
	SELECT fid.name, f.parent_path || '/' || fid.parent_folder AS parent_path, 
	    fid.SIZE FROM files_on_disk fid
		INNER JOIN files f ON fid.parent_folder = f.name
)
SELECT * FROM files;


/*
 * Advent of Code dec07 2022 example of 
 * walking a file system tree
 */
DROP TABLE IF EXISTS dec07;

create table dec07 (
	id integer generated by default as identity,
	file_system text
);

WITH dec07_cte AS ( 
	SELECT * FROM regexp_split_to_table($$$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k$$,'\r\n')
)
INSERT INTO dec07(file_system)
SELECT * FROM dec07_cte;

SELECT * FROM dec07;

/*
 * regexp_match returns an array of captured regex data
 */
with recursive commands as (
	select id,
		regexp_match(file_system, '\$ cd (.*)') as dir,
		regexp_match(file_system,'([\d]+) (.*)') as file from dec07
)
SELECT * FROM commands;

/*
 * step 2: recurse line by line through the
 * commands, looking for when we need to modify
 * the parent path
 */
with recursive commands as (
	select id,
		regexp_match(file_system, '\$ cd (.*)') as dir,
		regexp_match(file_system,'([\d]+) (.*)') as file from dec07
)
--SELECT * FROM commands;
,
walk_tree as (
	--Initial query, just static data to get started
	select 1::int id,
		'{}'::text[] as dir, 
		null::text file,
		null::int fsize	
	union all
	-- Check the first element of the directory array.
	-- 
	-- If it is not â€˜..â€™ and not NULL, append the directory to the array
	-- of directories.
	-- 
	-- If it is â€˜..â€™, remove the last element from the array because we 
	-- moved up a directory.
	select c.id+1, 
		case when c.dir[1] != '..' and c.dir is not null 
			then wt.dir || c.dir[1]
		when c.dir[1] = '..' THEN 
			-- remove the last element in the array
			trim_array(wt.dir,1)
		else wt.dir end dir,
		c.file[2], c.file[1]::int
	from commands c
		join walk_tree wt on c.id = wt.id
)
SELECT * FROM walk_tree;

/*
 * Finish the puzzle, now that we have 
 */
with recursive commands as (
	select id,
		regexp_match(file_system, '\$ cd (.*)') as dir,
		regexp_match(file_system,'([\d]+) (.*)') as file from dec07
)
--SELECT * FROM commands;
,
walk_tree as (
	--Initial query, just static data to get started
	select 1::int id,
		'{}'::text[] as dir, 
		null::text file,
		null::int fsize	
	union all
	-- Check the first element of the directory array.
	-- 
	-- If it is not â€˜..â€™ and not NULL, append the directory to the array
	-- of directories.
	-- 
	-- If it is â€˜..â€™, remove the last element from the array because we 
	-- moved up a directory.
	select c.id+1, 
		case when c.dir[1] != '..' and c.dir is not null 
			then wt.dir || c.dir[1]
		when c.dir[1] = '..' THEN 
			-- remove the last element in the array
			trim_array(wt.dir,1)
		else wt.dir end dir,
		c.file[2], c.file[1]::int
	from commands c
		join walk_tree wt on c.id = wt.id
)
--SELECT * FROM walk_tree;
,
paths (dir) as (
	select distinct dir
	from walk_tree 
	where CARDINALITY(dir) > 0
)
--SELECT dir, cardinality(dir) FROM paths;
,
sizes(dir, size) as (
	select p.dir, sum(fsize)
	from paths as p
	join walk_tree wt on wt.dir[:CARDINALITY(p.dir)] = p.dir
	group by p.dir
)
--SELECT * FROM sizes;
select sum(size) as space_freed
from sizes
where size < 100000;


